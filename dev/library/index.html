<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · GenericArpack.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GenericArpack.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#User-Friendly-Interfaces"><span>User Friendly Interfaces</span></a></li><li><a class="tocitem" href="#ArpackOp-types"><span>ArpackOp types</span></a></li><li><a class="tocitem" href="#Helpers"><span>Helpers</span></a></li><li><a class="tocitem" href="#Arpack-drivers"><span>Arpack drivers</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dgleich/GenericArpack.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="User-Friendly-Interfaces"><a class="docs-heading-anchor" href="#User-Friendly-Interfaces">User Friendly Interfaces</a><a id="User-Friendly-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#User-Friendly-Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.symeigs" href="#GenericArpack.symeigs"><code>GenericArpack.symeigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(Symmetric(A), k; kwargs...)  # maps to symeigs 
eigs(Hermitian(A), k; kwargs...)  # maps to hermeigs 
symeigs(A, k; kwargs...)          # A must be symmetric, although we don&#39;t check. 
symeigs(A, B, k; kwargs...)       # A must be sym, B must be sym. pos. def, not checked 
symeigs(op, k; kwargs...)         # uses ArpackOp to handle multiple problem types 
hermeigs(A, k; kwargs...)         # forces complex valued vectors; A not checked.     
hermeigs(A, B k; kwargs...)       # forces complex valued vectors; A not checked.     
symeigs(TV, TF, op, k; kwargs...) # the most general implmementation</code></pre><p>These functions compute <em>Symmetric and Hermitian Eigenspaces</em> hence, <code>symeigs</code> for symmetric eigenspace.</p><p>Calling sequence: the call is implemented with everything mapped to the single, most general call with symeigs. </p><p><strong>Type parameters</strong></p><ul><li><code>TV</code>: The element type of the vector information; we need <code>TV &lt;: Complex</code> for Hermitian problems</li><li><code>TF</code>: The element type of the factorization information; we need <code>TV &lt;: Real</code> for  all problems. </li></ul><p>Note that it is okay to mix different precisions, although the lowest precision will  determine the default tolerance; e.g. <code>TV = Float32</code>, <code>TF = Float64</code> will use a default tolerance from <code>Float32</code>. </p><p><strong>Arguments</strong></p><ul><li><code>Symmetric(A)</code> or <code>Hermitian(A)</code> a matrix whose type indicates it is symmetric or Hermitian</li><li><code>k::Integer</code> the size of the eigenspace to compute. (i.e. the number of eigenvectors)</li><li><code>A</code> a square matrix that <em>should</em> be symmetric (but we won&#39;t check)</li><li><code>B</code> or <code>Symmetric(B)</code> or <code>Hermitian(B)</code> like A, but for a generalized eigenvalue problem.  The matrix B will be factorized via factorize(B), if you need more control, use <a href="#GenericArpack.ArpackSymmetricGeneralizedOp"><code>ArpackSymmetricGeneralizedOp</code></a>, or see one of the more advanced generalized interfaces below. </li><li><code>op::ArpackOp</code> An Arpack instance that holds the minimal information we need to run Arpack</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>which</code>: which part of the spectrum to compute. There are a few choices: <ul><li><code>:LM</code> <em>(the default)</em> find the largest magnitude eigenspace </li><li><code>:SM</code> find the smallest magnitude eigenspace</li><li><code>:LA</code> find the largest algebraic value eigenspace </li><li><code>:SA</code> find the smallest algebraic value eigenspace     </li><li><code>:BE</code> find both smallest and largest algebraic eigenspace</li></ul></li><li><code>ncv</code>: the number of vectors used in the Arnoldi basis. The default value is <code>min(2k, n)</code>  where <code>n</code> is the dimension of the matrix. Increasing this value can help if there are  invariant subspaces with many nearby eigenvalues.</li><li><code>tol</code>: the tolerance on the error bound on the estimated eigenspace. The default value  is <code>max(eps(TF), eps(TV))/2</code>; if <code>TV</code> is a complex valued type, this means the underlying  element type. </li><li><code>v0</code>: a starting vector to build the initial basis. This should be of the same dimension  as the matrix itself. The default choice is to use a random vector by setting  <code>v0=nothing</code>. Note that  <code>GenericArpack.jl</code> includes it&#39;s own random number generator to  match the Fortran Arpack library. If you wish to match a sequence of calls, please  save the ArpackState information between subsequent calls. </li><li><code>maxiter</code>:  the maximum number of restarted Arnoldi bases to build. Default value is 300.  this is highly conservative and may be changed in future </li><li><code>failonmaxiter</code>: (default true) if the maximum number of iterations is hit and this is  true, then we force a hard error. Otherwise, we return information that can be used to run additional iterations. </li><li><code>ritzvec</code>: This determines if we compute eigenvector information or not. If not, then the matrix of eigenvectors will have zero columns. </li><li><code>state</code>: the ArpackState structure that stores information between calls. By default, we create a new state for each call. This stores information on the random number generator and information for the reverse communication interface.   </li></ul><p><strong>Output and results optional parameters</strong></p><ul><li><code>debug</code>: This allow debugging output.  This must be an instance of ArpackDebug().  See the field information as well as the Arpack debugging information to understand what is logged. </li><li><code>stats</code>: This tracks timing statistics and the number of various operations performed; it must be an instance of ArpackStats(). </li></ul><p><strong>Advanced optional parameters</strong></p><ul><li><code>mode</code>: by default, the mode is set by the input or type of arpack op. While you can override this by setting it, this may result in incorrect behavior. In particular, we will throw a warning if the op seems inappropriate for the mode. The best way to use this is to use one of the more advanced ops, such as <code>ArpackShiftInvertOp</code></li><li><code>bmat</code>: if <code>bmat=Val(:I)</code>, then this is a standard eigenvalue problem. If <code>bmat = Val(:G)</code> then it is a generalized eigenvalue problem. By default, the choice of call and ArpackOp determines <code>bmat</code> and this should be changed rarely. </li></ul><p><strong>Sample calls</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra, SparseArrays, GenericArpack
julia&gt; # standard real symmetric eigenvalue problem
julia&gt; n=100; symeigs(Tridiagonal(-ones(n-1),2*ones(n),-ones(n-1)).*(n+1), 5)
julia&gt; # real symmetric generalized eigenvalue problem
julia&gt; n=100; symeigs(Tridiagonal(-ones(n-1),2*ones(n),-ones(n-1)).*(n+1),
                      SymTridiagonal(4*ones(n),ones(n-1))*(1/(6*(n+1))), 5)
julia&gt; # use Float32 type for information on smallest eigenvalue problem
julia&gt; n=100; symeigs(Float32, ArpackSimpleOp(Diagonal(1.0:n)), 5; which=:SA)
julia&gt; # complex Hermitian eigenvalue problem 
julia&gt; n=100; symeigs(Tridiagonal(im*ones(n-1),2*ones(n).+0im,im*ones(n-1)).*(n+1), 5)
julia&gt; # mixed precision eigenvalue problem 
julia&gt; n=100; symeigs(Float16, Float64, ArpackSimpleOp(Diagonal(1.0:n)), 5; which=:SA)</code></pre><p><strong>See also</strong></p><p>If you wish more control over the interface and what is provided, your best solution is to work with the <a href="#GenericArpack.ArpackOp"><code>ArpackOp</code></a> types, or write your own (it is very easy!)</p><ul><li><a href="#GenericArpack.ArpackSimpleFunctionOp"><code>ArpackSimpleFunctionOp</code></a>: This wraps a general input to output function. </li><li><a href="#GenericArpack.ArpackNormalOp"><code>ArpackNormalOp</code></a>: This is the op type used in the svds function </li><li><a href="#GenericArpack.ArpackShiftInvertOp"><code>ArpackShiftInvertOp</code></a>: This is your best way to use the Shift Inver</li><li><a href="#GenericArpack.ArpackBucklingOp"><code>ArpackBucklingOp</code></a>: </li><li><a href="#GenericArpack.svds"><code>svds</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/interface.jl#L4-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.svds" href="#GenericArpack.svds"><code>GenericArpack.svds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">svds(A, k; kwargs...)
svds(T::Type, A, k; kwargs...)
svds(TV::Type, TF::Type, A, k; kwargs...)
svds(TV::Type, TF::Type, op, k; kwargs...)
complexsvds(op, k; kwargs...)</code></pre><p>TODO: Write documentation See examples... </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/interface.jl#L286-L295">source</a></section></article><h2 id="ArpackOp-types"><a class="docs-heading-anchor" href="#ArpackOp-types">ArpackOp types</a><a id="ArpackOp-types-1"></a><a class="docs-heading-anchor-permalink" href="#ArpackOp-types" title="Permalink"></a></h2><h3 id="User-facing-ArpackOp-types"><a class="docs-heading-anchor" href="#User-facing-ArpackOp-types">User-facing ArpackOp types</a><a id="User-facing-ArpackOp-types-1"></a><a class="docs-heading-anchor-permalink" href="#User-facing-ArpackOp-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackSimpleOp" href="#GenericArpack.ArpackSimpleOp"><code>GenericArpack.ArpackSimpleOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackSimpleOp(A)</code></pre><p>This corresponds to a simple eigenvalue problem Ax = lambda x, and builds a Julia object that represents the minimal information Arpack needs about the matrix to run an eigenvalue problem. </p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Anything that implements <code>Base.size</code>, <code>LinearAlgebra.mul!</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; op = ArpackSimpleOp(A)
juila&gt; size(op) == size(A,1)</code></pre><p>See also <a href="#GenericArpack.ArpackSymmetricGeneralizedOp"><code>ArpackSymmetricGeneralizedOp</code></a>, <a href="#GenericArpack.ArpackSimpleFunctionOp"><code>ArpackSimpleFunctionOp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L97-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackSimpleFunctionOp" href="#GenericArpack.ArpackSimpleFunctionOp"><code>GenericArpack.ArpackSimpleFunctionOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackSimpleFunctionOp(F::Function, n::Integer)</code></pre><p>This corresponds to a simple eigenvalue problem Ax = lambda x, but  takes a functional operator that we apply.</p><p><strong>Arguments</strong></p><ul><li><code>F::Function</code> this is a function (y,x) -&gt; mul!(y,A,x), i.e. a function  that writes <span>$A*x$</span> into <span>$y$</span></li><li><code>n::Integer</code> the dimension of the problem </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using GenericArpack, SparseArrays
julia&gt; function myf(y,x) 
       fill!(y, 0)
       y[1] += x[2] + x[100]
       for i in 2:99
         y[i] += x[i+1] + x[i-1]
       end
       y[100] += x[99] + x[1]
       end
julia&gt; op = ArpackSimpleFunctionOp(myf, 100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L335-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackSymmetricGeneralizedOp" href="#GenericArpack.ArpackSymmetricGeneralizedOp"><code>GenericArpack.ArpackSymmetricGeneralizedOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackSymmetricGeneralizedOp(A,invB,B)</code></pre><p>We need three operations: A<em>x, invB</em>x, B*x     B must also be symmetric, pos. def.  Note that if B can be factorized efficiently via Cholesky, then there is a better way to proceed. </p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; using GenericArpack, LinearAlgebra julia&gt; n = 100  julia&gt; A = Tridiagonal(-ones(n-1),2<em>ones(n),-ones(n-1)).</em>(n+1) julia&gt; B = Tridiagonal(ones(n-1),4<em>ones(n),ones(n-1)).</em>(1/(6*(n+1))) julia&gt; op = ArpackSymmetricGeneralizedOp(A, lu!(copy(B)), B)</p><p>See also <a href="#GenericArpack.ArpackSimpleOp"><code>ArpackSimpleOp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L445-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackNormalOp" href="#GenericArpack.ArpackNormalOp"><code>GenericArpack.ArpackNormalOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackNormalOp(A)</code></pre><p>This provides an <a href="#GenericArpack.ArpackSVDOp"><code>ArpackSVDOp</code></a> that is used as a bridge in <code>svds</code>  to call the symeigs routine. It maniuplates the so-called normal matrix  <span>$AA^H$</span> or <span>$A^H A$</span> depending on which  is smaller. Note that this function allocates memory to compute the operation, so it will not be safe to use with multiple threads. </p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Anything that implements <code>Base.size</code>, <code>LinearAlgebra.mul!(y,A,x)</code>, <code>LinearAlgebra.adjoint</code> and <code>LinearAlgebra.mul!(y,adjoint(A),x)</code>`</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; op = ArpackNormalOp(A)</code></pre><p>See also <a href="#GenericArpack.ArpackNormalFunctionOp"><code>ArpackNormalFunctionOp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L196-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackNormalFunctionOp" href="#GenericArpack.ArpackNormalFunctionOp"><code>GenericArpack.ArpackNormalFunctionOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackNormalFunctionOp(ax::Function, atx::Function, m::Integer, n::Integer)</code></pre><p><strong>Arguments</strong></p><ul><li><code>ax</code> A function to compute (y,x) and write y = A*x into the memory for y</li><li><code>atx</code> A function to compute (y,x) and write y = A^H*x into the memory for y</li><li><code>m</code> the number of rows of A</li><li><code>n</code> the number of rows of A</li></ul><p>See also <a href="#GenericArpack.ArpackNormalOp"><code>ArpackNormalOp</code></a>, <a href="#GenericArpack.ArpackSimpleFunctionOp"><code>ArpackSimpleFunctionOp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L395-L405">source</a></section></article><h3 id="In-development-ArpackOp-types"><a class="docs-heading-anchor" href="#In-development-ArpackOp-types">In-development ArpackOp types</a><a id="In-development-ArpackOp-types-1"></a><a class="docs-heading-anchor-permalink" href="#In-development-ArpackOp-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackShiftInvertOp" href="#GenericArpack.ArpackShiftInvertOp"><code>GenericArpack.ArpackShiftInvertOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackShiftInvertOp</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Do not use</header><div class="admonition-body"><p>Do not use this operator yet. It was just some prototype code.    </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L494-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackBucklingOp" href="#GenericArpack.ArpackBucklingOp"><code>GenericArpack.ArpackBucklingOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackBucklingOp</code></pre><pre><code class="nohighlight hljs">c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,
c           KG symmetric indefinite
c           ===&gt; OP = (inv[K - sigma*KG])*K  and  B = K.
c           ===&gt; Buckling mode</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Do not use</header><div class="admonition-body"><p>Do not use this operator yet. It was just some prototype code.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L541-L553">source</a></section></article><h3 id="Abstract-ArpackOp-Types"><a class="docs-heading-anchor" href="#Abstract-ArpackOp-Types">Abstract ArpackOp Types</a><a id="Abstract-ArpackOp-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-ArpackOp-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackOp" href="#GenericArpack.ArpackOp"><code>GenericArpack.ArpackOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackOp</code></pre><p>The general abstract ArpackOp interface.     </p><p>See also <a href="#GenericArpack.ArpackSimpleOp"><code>ArpackSimpleOp</code></a>,  <a href="#GenericArpack.ArpackSymmetricGeneralizedOp"><code>ArpackSymmetricGeneralizedOp</code></a>,  <a href="#GenericArpack.ArpackSimpleFunctionOp"><code>ArpackSimpleFunctionOp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.ArpackSVDOp" href="#GenericArpack.ArpackSVDOp"><code>GenericArpack.ArpackSVDOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArpackSVDSOp</code></pre><p>The general abstract ArpackSVDOp interface that bridges between eigenvaules and singular values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/idonow_ops.jl#L42-L47">source</a></section></article><h2 id="Helpers"><a class="docs-heading-anchor" href="#Helpers">Helpers</a><a id="Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.svd_residuals" href="#GenericArpack.svd_residuals"><code>GenericArpack.svd_residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">svd_residuals(A, U, s, V)
svd_residuals(A, SVD)
svd_residuals(A, U, s, V, k) # compute for only the top k 
svd_residuals!(r, A, U, s, V) # write result in place</code></pre><p>Compute the residuals of an SVD computation <span>$||A*V[:,i] - U[:,i]*sigma[i]||$</span>, and return the result in a vector. </p><p><strong>Using a matvec function</strong></p><p>Note that A can also be a function A(y,x), where y = A*x is updated  in place. e.g. <code>svd(A,U,s,V) == svd((y,x)-&gt;mul!(y,A,x), U,s,V)</code> are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/interface.jl#L366-L379">source</a></section></article><h2 id="Arpack-drivers"><a class="docs-heading-anchor" href="#Arpack-drivers">Arpack drivers</a><a id="Arpack-drivers-1"></a><a class="docs-heading-anchor-permalink" href="#Arpack-drivers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.dsaupd!" href="#GenericArpack.dsaupd!"><code>GenericArpack.dsaupd!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>call dsaupd      ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,        IPNTR, WORKD, WORKL, LWORKL, INFO )</p><p><strong>Arguments</strong></p><p>IDO     Integer.  (INPUT/OUTPUT)          Reverse communication flag.  IDO must be zero on the first          call to dsaupd .  IDO will be set internally to          indicate the type of operation to be performed.  Control is          then given back to the calling routine which has the          responsibility to carry out the requested operation and call          dsaupd  with the result.  The operand is given in          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).          (If Mode = 2 see remark 5 below)          ––––––––––––––––––––––––––––––-          IDO =  0: first call to the reverse communication interface          IDO = -1: compute  Y = OP * X  where                    IPNTR(1) is the pointer into WORKD for X,                    IPNTR(2) is the pointer into WORKD for Y.                    This is for the initialization phase to force the                    starting vector into the range of OP.          IDO =  1: compute  Y = OP * X where                    IPNTR(1) is the pointer into WORKD for X,                    IPNTR(2) is the pointer into WORKD for Y.                    In mode 3,4 and 5, the vector B * X is already                    available in WORKD(ipntr(3)).  It does not                    need to be recomputed in forming OP * X.          IDO =  2: compute  Y = B * X  where                    IPNTR(1) is the pointer into WORKD for X,                    IPNTR(2) is the pointer into WORKD for Y.          IDO =  3: compute the IPARAM(8) shifts where                    IPNTR(11) is the pointer into WORKL for                    placing the shifts. See remark 6 below.          IDO = 99: done          ––––––––––––––––––––––––––––––-</p><p>BMAT    Character<em>1.  (INPUT)          BMAT specifies the type of the matrix B that defines the          semi-inner product for the operator OP.          B = &#39;I&#39; -&gt; standard eigenvalue problem A</em>x = lambda<em>x          B = &#39;G&#39; -&gt; generalized eigenvalue problem A</em>x = lambda<em>B</em>x</p><p>N       Integer.  (INPUT)          Dimension of the eigenproblem.</p><p>WHICH   Character*2.  (INPUT)          Specify which of the Ritz values of OP to compute.</p><pre><code class="nohighlight hljs">     &#39;LA&#39; - compute the NEV largest (algebraic) eigenvalues.
     &#39;SA&#39; - compute the NEV smallest (algebraic) eigenvalues.
     &#39;LM&#39; - compute the NEV largest (in magnitude) eigenvalues.
     &#39;SM&#39; - compute the NEV smallest (in magnitude) eigenvalues.
     &#39;BE&#39; - compute NEV eigenvalues, half from each end of the
            spectrum.  When NEV is odd, compute one more from the
            high end than from the low end.
      (see remark 1 below)</code></pre><p>NEV     Integer.  (INPUT)          Number of eigenvalues of OP to be computed. 0 &lt; NEV &lt; N.</p><p>TOL     Double precision  scalar.  (INPUT)          Stopping criterion: the relative accuracy of the Ritz value          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).          If TOL .LE. 0. is passed a default is set:          DEFAULT = DLAMCH (&#39;EPS&#39;)  (machine precision as computed                    by the LAPACK auxiliary subroutine DLAMCH ).</p><p>RESID   Double precision  array of length N.  (INPUT/OUTPUT)          On INPUT:          If INFO .EQ. 0, a random initial residual vector is used.          If INFO .NE. 0, RESID contains the initial residual vector,                          possibly from a previous run.          On OUTPUT:          RESID contains the final residual vector.</p><p>NCV     Integer.  (INPUT)          Number of columns of the matrix V (less than or equal to N).          This will indicate how many Lanczos vectors are generated          at each iteration.  After the startup phase in which NEV          Lanczos vectors are generated, the algorithm generates          NCV-NEV Lanczos vectors at each subsequent update iteration.          Most of the cost in generating each Lanczos vector is in the          matrix-vector product OP*x. (See remark 4 below).</p><p>V       Double precision  N by NCV array.  (OUTPUT)          The NCV columns of V contain the Lanczos basis vectors.</p><p>LDV     Integer.  (INPUT)          Leading dimension of V exactly as declared in the calling          program.</p><p>IPARAM  Integer array of length 11.  (INPUT/OUTPUT)          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.          The shifts selected at each iteration are used to restart          the Arnoldi iteration in an implicit fashion.          ––––––––––––––––––––––––––––––-          ISHIFT = 0: the shifts are provided by the user via                      reverse communication.  The NCV eigenvalues of                      the current tridiagonal matrix T are returned in                      the part of WORKL array corresponding to RITZ.                      See remark 6 below.          ISHIFT = 1: exact shifts with respect to the reduced                      tridiagonal matrix T.  This is equivalent to                      restarting the iteration with a starting vector                      that is a linear combination of Ritz vectors                      associated with the &quot;wanted&quot; Ritz values.          ––––––––––––––––––––––––––––––-</p><pre><code class="nohighlight hljs">     IPARAM(2) = LEVEC
     No longer referenced. See remark 2 below.

     IPARAM(3) = MXITER
     On INPUT:  maximum number of Arnoldi update iterations allowed.
     On OUTPUT: actual number of Arnoldi update iterations taken.

     IPARAM(4) = NB: blocksize to be used in the recurrence.
     The code currently works only for NB = 1.

     IPARAM(5) = NCONV: number of &quot;converged&quot; Ritz values.
     This represents the number of Ritz values that satisfy
     the convergence criterion.

     IPARAM(6) = IUPD
     No longer referenced. Implicit restarting is ALWAYS used.

     IPARAM(7) = MODE
     On INPUT determines what type of eigenproblem is being solved.
     Must be 1,2,3,4,5; See under Description of dsaupd  for the
     five modes available.

     IPARAM(8) = NP
     When ido = 3 and the user provides shifts through reverse
     communication (IPARAM(1)=0), dsaupd  returns NP, the number
     of shifts the user is to provide. 0 &lt; NP &lt;=NCV-NEV. See Remark
     6 below.

     IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
     OUTPUT: NUMOP  = total number of OP*x operations,
             NUMOPB = total number of B*x operations if BMAT=&#39;G&quot;,
             NUMREO = total number of steps of re-orthogonalization.</code></pre><p>IPNTR   Integer array of length 11.  (OUTPUT)          Pointer to mark the starting locations in the WORKD and WORKL          arrays for matrices/vectors used by the Lanczos iteration.          ––––––––––––––––––––––––––––––-          IPNTR(1): pointer to the current operand vector X in WORKD.          IPNTR(2): pointer to the current result vector Y in WORKD.          IPNTR(3): pointer to the vector B * X in WORKD when used in                    the shift-and-invert mode.          IPNTR(4): pointer to the next available location in WORKL                    that is untouched by the program.          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.          IPNTR(6): pointer to the NCV RITZ values array in WORKL.          IPNTR(7): pointer to the Ritz estimates in array WORKL associated                    with the Ritz values located in RITZ in WORKL.          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.</p><pre><code class="nohighlight hljs">     Note: IPNTR(8:10) is only referenced by dseupd . See Remark 2.
     IPNTR(8): pointer to the NCV RITZ values of the original system.
     IPNTR(9): pointer to the NCV corresponding error bounds.
     IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
                of the tridiagonal matrix T. Only referenced by
                dseupd  if RVE= .TRUE. See Remarks.
     -------------------------------------------------------------</code></pre><p>WORKD   Double precision  work array of length 3<em>N.  (REVERSE COMMUNICATION)          Distributed array to be used in the basiArnoldi iteration          for reverse communication.  The user should not use WORKD          as temporary workspace during the iteration. Upon termination          WORKD(1:N) contains B</em>RESID(1:N). If the Ritz vectors are desired          subroutine dseupd  uses this output.          See Data Distribution Note below.</p><p>WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)          Private (replicated) array on each PE or array allocated on          the front end.  See Data Distribution Note below.</p><p>LWORKL  Integer.  (INPUT)          LWORKL must be at least NCV**2 + 8*NCV .</p><p><strong>Changes:</strong></p><p>Note that info is only used for Input.  INFO    Integer.  (INPUT/OUTPUT)          If INFO .EQ. 0, a randomly initial residual vector is used.          If INFO .NE. 0, RESID contains the initial residual vector,                          possibly from a previous run.</p><p><strong>Return value (this is <code>info</code> in Fortran)</strong></p><p>The return value is a pair           Error flag on output.          =  0: Normal exit.          =  1: Maximum number of iterations taken.                All possible eigenvalues of OP has been found. IPARAM(5)                returns the number of wanted converged Ritz values.          =  2: No longer an informational error. Deprecated starting                with release 2 of ARPACK.          =  3: No shifts could be applied during a cycle of the                Implicitly restarted Arnoldi iteration. One possibility                is to increase the size of NCV relative to NEV.                See remark 4 below.          = -1: N must be positive.          = -2: NEV must be positive.          = -3: NCV must be greater than NEV and less than or equal to N.          = -4: The maximum number of Arnoldi update iterations allowed                must be greater than zero.          = -5: WHICH must be one of &#39;LM&quot;, &#39;SM&quot;, &#39;LA&quot;, &#39;SA&#39; or &#39;BE&#39;.          = -6: BMAT must be one of &#39;I&#39; or &#39;G&#39;.          = -7: Length of private work array WORKL is not sufficient.          = -8: Error return from trid. eigenvalue calculation;                Informatinal error from LAPACK routine dsteqr .          = -9: Starting vector is zero.          = -10: IPARAM(7) must be 1,2,3,4,5.          = -11: IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.          = -12: IPARAM(1) must be equal to 0 or 1.          = -13: NEV and WHICH = &#39;BE&#39; are incompatible.          = -9999: Could not build an Arnoldi factorization.                   IPARAM(5) returns the size of the current Arnoldi                   factorization. The user is advised to check that                   enough workspace and array storage has been allocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/dsaupd.jl#L695-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericArpack.simple_dseupd!" href="#GenericArpack.simple_dseupd!"><code>GenericArpack.simple_dseupd!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Usage:   call dseupd        ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,        RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )</p><p>RVEC    LOGICAL  (INPUT)            Specifies whether Ritz vectors corresponding to the Ritz value            approximations to the eigenproblem A<em>z = lambda</em>B*z are computed.</p><pre><code class="nohighlight hljs">         RVEC = .FALSE.     Compute Ritz values only.

         RVEC = .TRUE.      Compute Ritz vectors.</code></pre><p>HOWMNY  Character*1  (INPUT)            Specifies how many Ritz vectors are wanted and the form of Z           the matrix of Ritz vectors. See remark 1 below.           = &#39;A&#39;: compute NEV Ritz vectors;           = &#39;S&#39;: compute some of the Ritz vectors, specified                  by the logical array SELECT.</p><p>SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)           If HOWMNY = &#39;S&#39;, SELECT specifies the Ritz vectors to be           computed. To select the Ritz vector corresponding to a           Ritz value D(j), SELECT(j) must be set to .TRUE..            If HOWMNY = &#39;A&#39; , SELECT is used as a workspace for           reordering the Ritz values.</p><p>D       Double precision  array of dimension NEV.  (OUTPUT)           On exit, D contains the Ritz value approximations to the           eigenvalues of A<em>z = lambda</em>B<em>z. The values are returned           in ascending order. If IPARAM(7) = 3,4,5 then D represents           the Ritz values of OP computed by dsaupd  transformed to           those of the original eigensystem A</em>z = lambda<em>B</em>z. If            IPARAM(7) = 1,2 then the Ritz values of OP are the same            as the those of A<em>z = lambda</em>B*z.</p><p>Z       Double precision  N by NEV array if HOWMNY = &#39;A&#39;.  (OUTPUT)           On exit, Z contains the B-orthonormal Ritz vectors of the           eigensystem A<em>z = lambda</em>B*z corresponding to the Ritz           value approximations.           If  RVEC = .FALSE. then Z is not referenced.           NOTE: The array Z may be set equal to first NEV columns of the            Arnoldi/Lanczos basis array V computed by DSAUPD .</p><p>LDZ     Integer.  (INPUT)           The leading dimension of the array Z.  If Ritz vectors are           desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.</p><p>SIGMA   Double precision   (INPUT)           If IPARAM(7) = 3,4,5 represents the shift. Not referenced if           IPARAM(7) = 1 or 2.</p><p>**** The remaining arguments MUST be the same as for the   ****   **** call to DSAUPD  that was just completed.               ****</p><p>NOTE: The remaining arguments</p><pre><code class="nohighlight hljs">       BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
       WORKD, WORKL, LWORKL, INFO

     must be passed directly to DSEUPD  following the last call
     to DSAUPD .  These arguments MUST NOT BE MODIFIED between
     the the last call to DSAUPD  and the call to DSEUPD .</code></pre><p>Two of these parameters (WORKL, INFO) are also output parameters:</p><p>WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)           WORKL(1:4<em>ncv) contains information obtained in           dsaupd .  They are not changed by dseupd .           WORKL(4</em>ncv+1:ncv<em>ncv+8</em>ncv) holds the           untransformed Ritz values, the computed error estimates,           and the associated eigenvector matrix of H.</p><pre><code class="nohighlight hljs">      Note: IPNTR(8:10) contains the pointer into WORKL for addresses
      of the above information computed by dseupd .
      -------------------------------------------------------------
      IPNTR(8): pointer to the NCV RITZ values of the original system.
      IPNTR(9): pointer to the NCV corresponding error bounds.
      IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
                 of the tridiagonal matrix T. Only referenced by
                 dseupd  if RVEC = .TRUE. See Remarks.
      -------------------------------------------------------------</code></pre><p>INFO    Integer.  (OUTPUT)           Error flag on output.           =  0: Normal exit.           = -1: N must be positive.           = -2: NEV must be positive.           = -3: NCV must be greater than NEV and less than or equal to N.           = -5: WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LA&#39;, &#39;SA&#39; or &#39;BE&#39;.           = -6: BMAT must be one of &#39;I&#39; or &#39;G&#39;.           = -7: Length of private work WORKL array is not sufficient.           = -8: Error return from trid. eigenvalue calculation;                 Information error from LAPACK routine dsteqr .           = -9: Starting vector is zero.           = -10: IPARAM(7) must be 1,2,3,4,5.           = -11: IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.           = -12: NEV and WHICH = &#39;BE&#39; are incompatible.           = -14: DSAUPD  did not find any eigenvalues to sufficient                  accuracy.           = -15: HOWMNY must be one of &#39;A&#39; or &#39;S&#39; if RVEC = .true.           = -16: HOWMNY = &#39;S&#39; not yet implemented           = -17: DSEUPD  got a different count of the number of converged                  Ritz values than DSAUPD  got.  This indicates the user                  probably made an error in passing data from DSAUPD  to                  DSEUPD  or that the data was modified before entering                   DSEUPD .</p><p><strong>Notes on Julia interface</strong></p><ul><li>we eliminate &#39;howmny&#39; and &#39;select&#39; as they aren&#39;t used in the Arpack code.                 </li><li>Julia doesn&#39;t need ldz, so we remove that too... </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GenericArpack.jl/blob/ee77044b23f2cf30c7d295af181024fa402265a3/src/dseupd.jl#L871-L985">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 10 November 2023 21:20">Friday 10 November 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
